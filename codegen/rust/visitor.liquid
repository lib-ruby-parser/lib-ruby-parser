// This file is autogenerated by {{ template }}

use crate::nodes::*;
use crate::Node;

/// Common trait for all visitors
///
/// ```rust
/// use lib_ruby_parser::{
///     nodes::{Class, Const},
///     traverse::visitor::{visit_class, Visitor},
///     Node,
/// };
///
/// struct ClassesCollector {
///     classes: Vec<String>,
/// }
///
/// impl Visitor for ClassesCollector {
///     fn on_class(&mut self, node: &Class) {
///         self.classes.push(fetch_const_name(&node.name));
///         visit_class(self, node);
///     }
/// }
///
/// fn fetch_const_name(name: &Node) -> String {
///     match name {
///         Node::Const(Const { name, .. }) => name.to_owned(),
///         other => panic!("Don't know how to fetch const name from {:?}", other),
///     }
/// }
///
/// use lib_ruby_parser::{Parser, ParserOptions, ParserResult};
/// let parser = Parser::new(
///     b"class A; class B; end; end".to_vec(),
///     ParserOptions::default(),
/// );
/// let ParserResult { ast, .. } = parser.do_parse();
/// let ast = ast.unwrap();
///
/// let mut collector = ClassesCollector { classes: vec![] };
/// collector.visit(&ast);
/// assert_eq!(
///     collector.classes,
///     vec![String::from("A"), String::from("B")]
/// );
/// ```
pub trait Visitor: Sized {
{% for node in nodes %}
    /// Invoked by a `Visitor` on entering into `{{ node.camelcase_name }}` node.
    ///
    /// Has a default implementation, but you can override it and (optionally) call
    /// `visit_{{ node.camelcase_name | camelcase_to_snakecase }}(node)` to continue traversing.
    fn on_{{ node.camelcase_name | camelcase_to_snakecase }}(&mut self, node: &{{ node.camelcase_name }}) {
        visit_{{ node.camelcase_name | camelcase_to_snakecase }}(self, node);
    }
{% endfor %}

    /// Generic `visit` router that calls `on_<type>` under the hood
    fn visit(&mut self, node: &Node) {
        match node {
            {% for node in nodes -%}
            Node::{{ node.camelcase_name }}(inner) => {
                self.on_{{ node.camelcase_name | camelcase_to_snakecase }}(inner);
            }
            {% endfor %}
        }
    }
}

{% for node in nodes %}
/// Visits all children of {{ node.camelcase_name }} node
#[allow(unused_variables)]
pub fn visit_{{ node.camelcase_name | camelcase_to_snakecase }}<V: Visitor>(visitor: &mut V, node: &{{ node.camelcase_name }}) {
    {% for field in node.fields %}
    {%- assign field_name = field.snakecase_name | escape_rust_keyword -%}

    {% case field.field_type %}
    {%- when "Node" -%}
        visitor.visit(&node.{{ field_name }});
    {%- when "Nodes" -%}
        for item in &node.{{ field_name }} { visitor.visit(item); }
    {%- when "MaybeNode" or "RegexpOptions" -%}
        if let Some(inner) = node.{{ field_name }}.as_ref() { visitor.visit(inner); }
    {%- when "Loc" or "MaybeLoc" or "Str" or "RawStr" or "MaybeStr" or "Chars" or "StringValue" or "U8" -%}
        // skip {{ field_name }}
    {%- else -%}
        compile_error!("Unsupported node field type {{ field.field_type }}");
    {% endcase %}
    {% endfor %}
}
{% endfor %}
